Outra forma de fazer a função connectToRMIServer no RMIServer.java
Esta forma foi a primeira implementada e é funcional, mas pareceu-me pouco correta do ponto de vista de flow de execução.

Caso a outra nao de por algum motivo, ela está aqui:

// try {
        // // Tentar primeiro conectar ao primary RMIServer(no caso de ser backup)
        // ci = (RMIInterface) Naming.lookup("RMIConnection");
        // String msg = ci.sayHello("server");
        // System.out.println(msg);
        // this.isBackup = true;
        // } catch (Exception e) { // Usually java.rmi.ConnectException
        // // Qual a excecao?
        // System.out.println("No primary RMIServer yet. Connecting...");
        // } finally {
        // // Se nao for o backup server, cria ligacao
        // if (!isBackup) {
        // try {
        // LocateRegistry.createRegistry(1099).rebind("RMIConnection", this);
        // System.out.println("Primary RMIServer ready...");
        // System.out.println("Print model: \"[Message responsible] Message\"");
        // } catch (Exception e) {
        // System.out.println("\nSomething went wrong. Aborting program...");
        // System.exit(-1);
        // }
        // }
        // }
        // Tenta ser servidor


ABORDAGEM 2:

// try {
        // LocateRegistry.createRegistry(RMIPORT).rebind(RMINAME, this);
        // this.isBackup = false;
        // System.out.println("Primary RMIServer ready...");
        // System.out.println("Print model: \"[Message responsible] Message\"");
        // } catch (Exception e) {
        // if (e instanceof java.rmi.server.ExportException) {
        // // Ja ha conexao. Quer dizer que temos de tomar posicao de backup server
        // try {
        // ci = (RMIInterface) Naming.lookup("RMIConnection");
        // String msg = ci.sayHello("server");
        // System.out.println(msg);
        // this.isBackup = true;
        // checkPrimaryServerStatus();
        // } catch (Exception er) {
        // System.out.println(
        // "\nERROR: Something went wrong. Couldn't be either primary or secondary
        // server. Aborting program...");
        // System.out.println("Exception: " + er);
        // System.exit(-1);
        // }
        // } else {
        // System.out.println("\nERROR: Something went wrong. Aborting program...");
        // System.out.println("Exception: " + e);
        // System.exit(-1);
        // }
        // }


Usar timer em vez de thread sleep:

 // Timer timer = new Timer();
        // TimerTask myTask = new TimerTask() {
        // @Override
        // public void run() {
        // // whatever you need to do every 2 seconds
        // try {
        // String res = ci.testPrimary();
        // System.out.println("[Primary server] " + res);
        // } catch (RemoteException e) {
        // System.out.println("Primary server not responding. Assuming primary
        // functions...");
        // LocateRegistry.createRegistry(RMIPORT).rebind(RMINAME, this);
        // timer.cancel();
        // }
        // }
        // };

        // timer.schedule(myTask, 2000, 2000);